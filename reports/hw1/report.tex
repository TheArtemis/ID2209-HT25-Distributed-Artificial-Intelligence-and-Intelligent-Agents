\documentclass[a4paper,12pt]{article}

% --- PACKAGES ---
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{float}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{geometry}
\usepackage{xcolor}
\usepackage{enumitem}

% --- PAGE SETUP ---
\geometry{margin=2.5cm}
\setlength{\headheight}{14.5pt}
\setlength{\parskip}{0.7em}
\setlength{\parindent}{0pt}
\pagestyle{fancy}
\fancyhf{}
\rhead{DAIIA Assignment Report}
\lhead{Deflorian, Fragale, Skarbalius}
\cfoot{\thepage}

% --- SECTION FORMATTING ---
\titleformat{\section}{\large\bfseries\color{blue}}{\thesection.}{0.5em}{}
\titleformat{\subsection}{\bfseries}{\thesubsection}{0.5em}{}
\titleformat{\subsubsection}[runin]{\bfseries}{\thesubsubsection}{0.5em}{}[.]

% --- TITLE ---
\title{\textbf{DAIIA Assignment Report}\\[0.5em]
\large Course: [Distributed Artificial Intelligence and AI Agents] \\[0.3em]
Assignment: Homework 1}
\author{Lorenzo Deflorian, Riccardo Fragale, Juozas Skarbalius \\[0.3em]
KTH Royal Institute of Technology \\[0.3em]
}
\date{\today}

\begin{document}

\maketitle
\tableofcontents
\newpage

% --- SECTION 1 ---
\section{Running Instructions}
Import the ZIP file given on GAMA and go to the folder assignment1/models. You will find a file
called Festival.gaml where our model for the homework is implemented.
Then, from the interface of GAMA, click on the play button and you will see a simulation.
Use the tools provided by the GAMA simulation interface to adjust the speed, read the outputs
and verify on screen that everything is working correctly.
Note that changing the parameters \textit{numCenter,numShop and numGuests} will change the number of 
agents that will appear on the screen and be part of the simulation. 

% --- SECTION 2 ---
\section{General Overview}

\subsection{Agents}
We have defined 4 main species:
\begin{itemize}
    \item InformationCenter
    \item Shop 
    \item SecurityGuard
    \item Guest
\end{itemize}
We also have two subspecies of Guest that are called SmartGuest and BadApple and they have been implemented to obtain the objectives
requested by challenge 1 and 2.

The agent of type \textbf{InformationCenter} is responsible to give informations to all the agents that are asking him where the shops 
are. He knows the locations of them and is also connected to a SecurityGuard that will be helpful for the 
purpose of the second challenge. Regarding the aspect of this agent, it is depicted as a black square of length 5 and its location
is right in the center of the field where the simulation is happening. All the other agents know by default the position of the InformationCenter.

A \textbf{Shop} is an agent responsible of replenishing food or water to all the guests that are coming to them.
They are divided into food shops and water shops and their position changes in each simulation.
Water shops are depicted as grey triangles while food shops are red triangles.


The \textbf{Guest}, instead, takes part in the festival and basically wanders randomly unless it is 
either hungry or thirsty. In this case it goes to the InformationCenter and asks
where to find food or water to fulfill its need. Then he starts moving to the location
given by the InformationCenter and "charges its batteries". Then, it continues moving aimlessly unless 
it feels hungry or thirsty again(or both). 
The initial value for hunger and thirst are set to 0, the maximum value reachable is 1000 and the threshold is set to 300.
A guest is a pink dot.

As we said before, there is also the \textbf{SmartGuest} that has a memory and so it is able to remember the locations
of the shops visited. In this way he could move less with respect to normal guests and it will satisfy its need faster. The SmartGuest
appears on screen as a yellow dot.

The other subtype of Guest, called \textbf{BadApple} is requested for challenge 2 and it has the ability to 
follow a guest and attack it, either by changing direction towards the guest or by reducing/adding thirstiness and hungriness.
Other guests can report him to the InformationCenter which will use the SecurityGuard to kill the BadApple.

Last but not the least, there is the \textbf{SecurityGuard} that is responsible to catch and kill all the badApples
that do not follow the rules of the festival and must be eliminated.
The security guard is a blue dot and its starting position is north-west with respect to the InformationCenter.

\subsection{Assumptions}
Our model has 1 InformationCenter, 1 SecurityGuard, 4 Shops (two of which of type \textit{food} and two of type \textit{water}).
Regarding the Guests, we have defined 3 SmartGuests, 10 guests without memory and 4 BadApples.

\subsection{Goals}
The goals of this homework are:
\begin{itemize}
    \item Introduction to the Gama platform
    \item Working with agents
    \item Learning the GAMA syntax
    \item Creating different types of agents
    \item Starting basic simulations
    \item Little bit of movement and behaviour
\end{itemize}



% --- SECTION 3 ---
\section{Basic implementation}

\subsubsection*{3.1 Explanation}
The basic implementation required us to create a simulation of a festival where Guests get hungry or 
thirsty. If they do, they should go to an Information Center to ask for the 
nearest Shop that gives them what they need. Afterward, the Guests 
should simply keep doing something until they get hungry/thirsty again (they wander randomly).

\subsubsection*{3.2 Code}
For this challenge we implemented all the requested agents and we setup a system through which there is a communication
between the agents. 

First of all, a thing we need to specify is that every loop the hunger and the thirst are updated in the following way
\begin{verbatim}
  reflex update_needs {
    	hunger <- min(maxHunger, hunger + rnd(0, 1));
        thirsty <- min(maxThirst, thirsty + rnd(0, 1));
    }
\end{verbatim}
In fact the need of food and water increase randomically (maximums and threshold are already specified in the previous section of this document).

Going on, this is the portion of code 
where we designed the interaction between the information center and the guest.

\begin{verbatim}
reflex reached_info_center when:
        infoCenter != nil
        and onTheWayToShop = false
        and targetShop = nil
        and (location distance_to infoCenter.location) < 1.0 {

        // Check BOTH needs
        bool needFood <- (hunger >= hungerThreshold);
        bool needWater <- (thirsty >= thirstThreshold);
        
        // If no needs, exit early
        if (!needFood and !needWater) {
            return;
        }
        
        // Determine which need to address
        string primaryNeed;
        
        if (hunger = thirsty) {
            // If equal, choose randomly
            primaryNeed <- one_of(["food", "water"]);
        } else if (hunger > thirsty) {
            primaryNeed <- "food";
        } else {
            primaryNeed <- "water";
        }
        
        targetShop <- infoCenter.getShopFor(need: primaryNeed);
        
        if (targetShop = nil) {
            write "No target shop found for " + primaryNeed;
            return; 
        }
               
        onTheWayToShop <- true;
        currentAction <- "-> " + primaryNeed + " shop";
        write "Going to " + targetShop + " to get " + primaryNeed + " - hunger: " + hunger + ", thirst: " + thirsty;
	}
\end{verbatim}


The info center checks the need of the guest and assign him a shop to go.
The guest then starts going to the target shop.
Whenever the guests are not thirsty nor hungry they remain on idle and they wander as it can be seven
from the piece of code below.
\begin{verbatim}
  reflex wander when: hunger < hungerThreshold and thirsty < thirstThreshold and onTheWayToShop = false and targetShop = nil and beingAttacked = false {
        do wander speed: movingSpeed;
    }
\end{verbatim}.

One important aspect is that guests know the position of the InformationCenter by default.
\begin{verbatim}
  ask guests {
            	infoCenter <- center[0];
        	}
\end{verbatim}
This ask is called inside the init and will be applied also for the other type of guests defined 
for the two challenges.

Finally, when the user reaches a shop, the hunger or the thirst are solved thanks to this
reflex and the action it is subsequently calling.
   
\begin{verbatim}
  reflex reached_shop when: targetShop != nil and (location distance_to targetShop.location) < 1.0 {      
        
        // Satisfy the need for this shop type
        do satisfy_needs;        
        
    }

    action satisfy_needs {
		string shopType <- targetShop.getShopType("");
		if (shopType = "food") {
            hunger <- 0;
            write "Ate food! Hunger reset.";
        } else if (shopType = "water") {
            thirsty <- 0;
            write "Drank water! Thirst reset.";
        }
	}
\end{verbatim}

\subsubsection*{3.3 Demonstration}
I will be providing a couple of use case for this initial part of the homework.
\begin{enumerate}
  \item An agent is assigned a food shop when it is hungry
  \item An agent gets food and so hungry is set back to 0
\end{enumerate}

For the following two subsections we did the screenshots considering only a normal guest without memory,
4 shops and an InformationCenter at the centre of the map.

\subsubsection*{3.3.1 Shop assignment}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{imgs/screenshots/basic_implementation/shop_assignment.png}
  \caption{A food shop is assigned to the guest}
  \label{fig:shop_assignment}
\end{figure}

As it can be seen, the agent ask the info center where to go and the info center tell him to go to a food shop.
Then the guest start moving toward the assigned shop.

\subsubsection*{3.3.2 Replenish hungriness}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{imgs/screenshots/basic_implementation/replenish attribute.png}
  \caption{Hungriness is set to 0}
  \label{fig:replenish_attribute}
\end{figure}
As it can be seen, the agent buys and eats food. Then it goes back to the info center
sine the thirstiness is above the threshold.


% --- SECTION 4 ---
\section{Challenge 1}

\subsection*{Smart Guests}
\subsubsection*{4.1 Explanation}
For this challenge we implemented a new type of Guest, called SmartGuest, that has a memory of the shops he has visited.
This way if he gets hungry or thirsty again, he can decide to either go to the InformationCenter to ask for a new shop or go directly to a known shop.

\subsubsection*{4.2 Code}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{imgs/code/reach_info_center_updated.png}
  \caption{Code snippet for SmartGuest behavior}
  \label{fig:reach_info_smart}
\end{figure}

The code snippet in Figure \ref{fig:reach_info_smart} shows how the SmartGuest decides whether to go to a known shop or ask the InformationCenter for a new one. With a probability of 50\%, the SmartGuest chooses to visit a previously known shop from its memory of visited places. It randomly selects one shop that satisfies its current need (food or water) and heads there directly; otherwise it behaves like a normal Guest and goes to the InformationCenter.

Whenever a SmartGuest visits a shop, it adds that shop to its list of visited places so it can remember it for future needs, reducing travel time on repeated needs.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{imgs/code/smartGuessShop.png}
  \caption{Code snippet for shop selection with memory}
  \label{fig:smartguess}
\end{figure}

Inside the info center we give the SmartGuest a shop that he has not visited yet, if any is available.

SmartGuests are represented as yellow dots on the simulation screen.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{imgs/screenshots/smart_guests/sg_less_steps.png}
  \caption{SmartGuests walking less due to memory}
  \label{fig:memory}
\end{figure}

As shown in Figure \ref{fig:memory}, SmartGuests walk less compared to normal Guests because they can go directly to known shops instead of asking the InformationCenter every time they get hungry or thirsty.

\subsubsection*{4.3 Demonstration}
Provided use cases for this challenge:
\begin{enumerate}[leftmargin=*]
  \item A guest with no memory goes to the info center.
  \item A smart guest with memory still goes to the infor center to discover a new shop.
  \item A smart guest decides to go to a known food shop from its memory.
  \item A smart guest decides to go to a known water shop from its memory.
\end{enumerate}

\subsection*{4.3.1 Guest with no memory}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{imgs/screenshots/smart_guests/sg_no_mem_info_center.png}
  \caption{Guest with no memory going to Information Center}
  \label{fig:case1}
\end{figure}

In Figure \ref{fig:case1}, we see a Smart Guest (yellow dot) that has no memory of shops. When it gets hungry, it goes to the Information Center (black square) to ask for the nearest food shop.

\subsection*{4.3.2 Smart Guest discovering new shop}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{imgs/screenshots/smart_guests/sg_1_mem_info_center.png}
  \caption{Smart Guest discovering a new shop}
  \label{fig:case2}
\end{figure}

In Figure \ref{fig:case2}, we see a Smart Guest (yellow dot) that already has one shop in its memory. However, it decides to go to the Information Center (black square) to discover a new shop instead of going to the known one.

\subsection*{4.3.3 Smart Guest going to known food shop}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{imgs/screenshots/smart_guests/sg_known_foodshop.png}
  \caption{Smart Guest going to known food shop}
  \label{fig:case3}
\end{figure}

In Figure \ref{fig:case3}, we see a Smart Guest (yellow dot) that has a food shop in its memory. When it gets hungry, it decides to go directly to the known food shop (red triangle) instead of asking the Information Center.

\subsection*{4.3.4 Smart Guest going to known water shop}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{imgs/screenshots/smart_guests/sg_known_watershop.png}
  \caption{Smart Guest going to known water shop}
  \label{fig:case4}
\end{figure}

In Figure \ref{fig:case4}, we see a Smart Guest (yellow dot) that has a water shop in its memory. When it gets thirsty, it decides to go directly to the known water shop (grey triangle) instead of asking the Information Center.

\section{Challenge 2: SecurityGuard and Bad Apples}
\subsection*{5.1 Explanation}
For this challenge we implemented the behavior of a BadApple agent (a guest type that attacks other guests) and a SecurityGuard agent that eliminates BadApples when reported by other guests.
Bad behaving agents are reported by the victim Guest agent to the InformationCenter, which then instructs the SecurityGuard to locate and eliminate the reported BadApple.
\subsection*{5.2 Code}
The BadApple agent randomly selects a target Guest to follow and attack. When it gets close enough to the target, it performs an attack by reducing the target's hunger or thirst levels, or by shaking the victim by bumping into it.
When a Guest is attacked, it reports the incident to the InformationCenter. The InformationCenter then instructs the SecurityGuard to locate and eliminate the reported BadApple.
The SecurityGuard moves towards the BadApple's location and "kills" it upon reaching it.
\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{imgs/screenshots/bad/image.png}
  \caption{Code snippet for BadApple attack behavior}
  \label{fig:badAppleCode}
\end{figure}
\subsection*{5.3 Demonstration}
Provided use cases for this challenge:
\begin{enumerate}[leftmargin=*]
  \item BadApple scans and approaches its targets
  \item A BadApple attacks a Guest.
  \item InformationCenter is notified about the attack and informs the SecurityGuard.
  \item The SecurityGuard locates and eliminates the BadApple.
\end{enumerate}
\subsubsection*{5.3.1 BadApple scans and approaches its targets}
The BadApple agent maintains a list of all other Guest agents in the simulation. It randomly selects one Guest from this list as its target and starts moving towards it.
\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{imgs/screenshots/bad/bad_approaching.png}
  \caption{BadApple approaching its target Guest}
  \label{fig:badAppleApproach}
\end{figure}
\subsubsection*{5.3.2 BadApple Attack}
Each BadApple, which is a sub-agent of Guest, maintains a list of all other Guest agents. 
It randomly selects a target Guest from this list and starts following it.
When the BadApple gets within a certain distance of its target Guest, it performs an attack by randomly decreasing the target's hunger or thirst levels, or shaking the victim by bumping into it.
Initial attack is illustrated in the figure below.
Guest detects when it is being attacked by a BadApple. Upon detection, the victim Guest reports the incident to the InformationCenter by going to InformationCenter and notifying it about the BadApple's behavior.
\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{imgs/screenshots/bad/attack_in_progress.png}
  \caption{Simulation snippet when BadApple is attacking a Guest}
  \label{fig:badAppleAttack}
\end{figure}
\subsubsection*{5.3.3 InformationCenter is notified about the attack and informs the SecurityGuard}
Upon receiving a report from a victim Guest about a BadApple attack, the InformationCenter records the location of the reported BadApple.
The Information Center then instructs the Security Guard to locate and eliminate the reported BadApple.
\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{imgs/screenshots/bad/attack_reported.png}
  \caption{InformationCenter notified about BadApple attack}
  \label{fig:infoCenterNotified}
\end{figure}
\subsubsection*{5.3.4 The SecurityGuard locates and eliminates the BadApple.}
The SecurityGuard receives the location of the reported BadApple from the InformationCenter. It puts the BadApple agent into the list of misbehaving agents.
Then it approaches and neutralizes the closest BadApple to guard's current position. 
\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{imgs/screenshots/bad/guard_kills.png}
  \caption{Security Guard eliminating the BadApple}
  \label{fig:securityGuardKill}
\end{figure}

% --- SECTION 5 ---
\section{Final Remarks}
In conclusion, this assignment provided a comprehensive introduction to the GAMA platform and agent-based modeling. We successfully implemented a festival simulation with various agent types, including Guests, SmartGuests, BadApples, InformationCenters, and SecurityGuards. Through this project, we gained hands-on experience in designing agent behaviors, inter-agent communication, and managing complex interactions within a simulated environment.


\end{document}