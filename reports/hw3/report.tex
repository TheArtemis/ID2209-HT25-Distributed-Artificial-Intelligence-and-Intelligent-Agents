\documentclass[a4paper,12pt]{article}

% --- PACKAGES ---
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{geometry}
\usepackage{xcolor}
\usepackage{enumitem}

% --- PAGE SETUP ---
\geometry{margin=2.5cm}
\setlength{\parskip}{0.7em}
\setlength{\parindent}{0pt}
\pagestyle{fancy}
\fancyhf{}
\rhead{DAIIA Assignment Report}
\lhead{Your Name}
\cfoot{\thepage}

% --- SECTION FORMATTING ---
\titleformat{\section}{\large\bfseries\color{blue}}{\thesection.}{0.5em}{}
\titleformat{\subsection}{\bfseries}{\thesubsection}{0.5em}{}
\titleformat{\subsubsection}[runin]{\bfseries}{\thesubsubsection}{0.5em}{}[.]

% --- TITLE ---
\title{\textbf{DAIIA Assignment Report}\\[0.5em]
\large Course: [Distributed Artificial Intelligence and AI Agents] \\[0.3em]
Assignment: Homework 3}
\author{Lorenzo Deflorian, Riccardo Fragale, Juozas Skarbalius \\[0.3em]
KTH Royal Institute of Technology \\[0.3em]
}
\date{\today}
\begin{document}


\maketitle
\tableofcontents
\newpage


% --- SECTION 1 ---
\section*{Running Instructions}
Import the ZIP file given on GAMA and go to the folder assignment3/models. You will find a file
called NQueen.gaml where our model for task 1 is implemented.
Then, from the interface of GAMA, click on the play button and you will see a simulation.
Use the tools provided by the GAMA simulation interface to adjust the speed, read the outputs
and verify on screen that everything is working correctly.
There is a parameter in the global of the module, called queens, that can be modified and defines the number of 
queens in the chess board. It is modifiable and should be used to verify that our code 
works for all N between 4 and 19.
Regarding task 1, in the same folder assignment3/models there is a .gaml file called FestivalStages.
Also in this case open it and play the simulation.

% --- SECTION 2 ---
\section{Task1: NQueen}
\subsection*{General overview}
We have to solve the N Queens problem; in particular the following are the rules of the game:
\begin{itemize}
    \item Create a NxN size chessboard, placing N queens on it
    \item No two queens can share the same row
    \item No two queens can share the same column
    \item No two queens can share the same diagonal line
\end{itemize}
Starting from a random situation the Queens should adjust their position so that they do not 
violate the rules and they found a correct arrangement. This property must be validfor 
$N \in \{4,\dots,19\}$.
In our setup we have a ChessBoard that appears on screen and a certain number of Queen agents,
defined by the variable queens (as said in the running instructions).
Each queen is an agent, they are able to communicate between each other through \textit{"fipa-contract-net"} protocol.
In our solution each queen is only able to communicate to its predecessor and 
to its successor.
There is a sort of recursive procedure in which if a queen has no available position, 
she must let her predecessor know and ask her to reposition her.
If also the predecessor has no available positions left, she must message her predecessor and so on and so for 
up until a correct arrangement is found.
Queens in correct positions are depicted in green while queens that have not found the correct placement are depicted in red.



\subsection*{Code}
First of all, each Queen is positioned on the chessBoard almost randomically
using the following init procedure:
\begin{verbatim}
    chessBoardCell myCell <- one_of (chessBoardCell);
    [...]
     init {
        //Assign a free cell
        loop cell over: myCell.neighbours{
            if cell.queen = nil{
                myCell <- cell;
                break;
            }
        }

        location <- myCell.location;
        myCell.queen <- self;
        add self to: allQueens;
        do refreshOccupancyGrid;
    }
\end{verbatim}
The procedure starts by calculating the occupancyGrid and verifying whether there are conflicts with respect to the rules.
When a conflict is found, queens need to move. 
The core relocation logic lives in the needToMove action. If a queen is in a conflict (indicated by a red color) and has no immediately free safe cells, it initiates negotiation.
Unlike the previous approach based on visibility, the queens are organized in a circular linked list. Each queen is assigned a specific \texttt{predecessor} and \texttt{successor} during initialization. When stuck, a queen sends a request specifically to its predecessor.

\begin{verbatim}
    // Communicate via chain: ONLY ask predecessor
    if predecessor != nil and !awaitingResponse{
        do start_conversation to: [predecessor] 
        protocol: 'fipa-contract-net' performative: 'cfp' 
        contents: ['request_move', string(self.myCell.grid_x), 
                   string(self.myCell.grid_y), name];
        
        awaitingResponse <- true;
        messageContext <- "chain_request";
    }
\end{verbatim}
The requester includes its own name in the message so that if the request is forwarded down the chain, the eventual helper knows who to reply to.

Incoming CFPs trigger the \texttt{handleCFP} reflex. The logic follows a "Chain of Responsibility" pattern:
\begin{enumerate}
    \item \textbf{If the receiver can move:} It moves to a free spot, effectively freeing its old cell. It then sends a \texttt{PROPOSE} message directly to the \texttt{originalRequester} (extracted from the message content) telling them the position is now available.
    \item \textbf{If the receiver cannot move:} It acts as a middleman. It forwards the CFP to its own \texttt{predecessor}, preserving the \texttt{originalRequester}'s name. It then sends a \texttt{REFUSE} to the immediate sender to close that specific transaction.
    \item \textbf{Chain Exhaustion:} If the request circles back to the original sender (Full Circle), the chain is exhausted, and the request is dropped to prevent infinite loops.
\end{enumerate}

\begin{verbatim}
    reflex handleCFP when: !empty(cfps){
        if length(myOptions) > 0 {
            // Move and notify original requester
            do start_conversation to: [originalQueen] ...
            performative: 'propose' 
            contents: ['position_available', string(oldCell.grid_x), ...];
        } else {
            // Forward to predecessor
            do start_conversation to: [predecessor] ... performative: 'cfp'
                contents: ['request_move', ..., originalRequester];
        }
    }
\end{verbatim}

The \texttt{handlePropose} reflex processes the resolution. When a queen in the chain finds a spot and moves, it sends a \texttt{'position\_available'} message to the queen that started the chain.
\begin{verbatim}
    reflex handlePropose when: !empty(proposes) and awaitingResponse{
        if contents[0] = 'position_available'{
            // Move to the cell freed by the helper
            myCell <- freedCell;
            location <- freedCell.location;
            do accept_proposal 
            message: proposalMessage contents: ['move_completed'];
        }
    }
\end{verbatim}
This creates a robust system where a single request can ripple through the entire population of queens until one is found that can shift to accommodate the group, resolving deadlocks that occurred in the visibility-based approach.

Finally, to provide visual feedback on the solution state, the queens update their color dynamically:
\begin{itemize}
    \item \textbf{Red:} The queen is currently in a conflict (occupancy grid value $>0$).
    \item \textbf{Green:} The queen is in a safe position (occupancy grid value $==0$).
\end{itemize}
The simulation is considered solved when all queens turn green.
The result is clearer separation: messages carry intent, reflexes react to performatives, and actions perform local state updates.


\subsection*{Demonstration}
We will show below a couple of situations proving that our implementation is 
correct using N = 4. In our opinion it would definitely be better for a reader
to run many simulations and verify that the N Queen problem is solved for that randomical beginning position.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{imgs/starting_point.png}
    \caption{Starting point}
    \label{fig:starting_point}
\end{figure}
As it can be seen from \ref{fig:starting_point} the queens are placed correctly on the map.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{imgs/middle_point.png}
    \caption{Queens are moving}
    \label{fig:queens_moving}
\end{figure}

\ref{fig:queens_moving} shows that queens are communicating and changing their position
in order to find a correct placement. It is clear also that sometimes the request 
is passed from predecessor to predecessor until someone can move.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{imgs/position_found.png}
    \caption{Position found}
    \label{fig:position_found}
\end{figure}

Finally, \ref{fig:position_found} shows that the position in found.

We will also add a picture of what happens inside a run with N=19.
Clearly the logs are more and the situation might be
definitely more complex so more loops are needed to find the correct placement
for all the queens in the chessboard.


\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{imgs/19_queens.png}
    \caption{19 queens moving on the chessboard}
    \label{fig:nineteen}
\end{figure}





% --- SECTION 3 ---
\section{Task 2: Positioning speakers at main stage}
For the purpose of this task we decide to eliminate the features of the previous homeworks related to 
the festival except for the InformationCenter and the skeleton of the normal guest.
We were asked to put some stages into the festival which host an act for a different amount of time.
The guest must know their position since the beginning of the simulation 
and must decide to go and attend an event at a festival based on a utility function.
Basically, the decision is based on the guest preference and the characteristic of each stage 
related to some properties (e.g sound system ,light visuals etc).
Guest communicate with stages through FIPA and after a "discussion" they must select 
the stage with the highest utility.

\subsection*{3.1 Explanation}
Describe what this section requires and how you approached solving it.

\subsection*{3.2 Code}
During initialization the model creates one InformationCenter,
three Stage agents and ten Guests. 
Each guest receives a list of all stages (and also knows their position) as shown below
\begin{verbatim}
    ask guests {
                set stages <- allStages;
        	}   
\end{verbatim}
Each Stage has three key properties: 
\begin{itemize}
    \item lightShow (0–100)
    \item speaker (0–100)
    \item musicStyle (0–100)
\end{itemize} 
These are randomly generated and represent the stage's entertainment characteristics.
Stages also have a starting time and a duration, both different for each stage
and randomically generated.
Each guest has individual preferences 
(lightShowPreference, speakerPreference, musicStylePreference), 
all randomly initialized in the interval 0 to 100. 
Utility for a stage is computed as follows:
\begin{verbatim}
    action compute_utilities(list<int> stats, Stage sender) {
    int lightShow <- stats[0];
    int speaker <- stats[1];
    int musicStyle <- stats[2];
    int utility <- lightShowPreference * lightShow 
    + speakerPreference * speaker + musicStylePreference * musicStyle;
    utilities[sender] <- utility;
    }
\end{verbatim}
Guests request stage statistics using FIPA Contract Net Protocol. 
The guest sends a cfp (Call For Proposal) performative to all stages with contents ["stats"].
\begin{verbatim}
    reflex request_utilities when: hasRequestedUtilities = false {
    write 'Requesting utilities from stages';
    do start_conversation to: list(Stage) 
    protocol: 'fipa-contract-net' performative: 'cfp' contents: ["stats"];
    hasRequestedUtilities <- true;
}
\end{verbatim}
When a stage receives a CFP with content "stats",
it responds immediately with a propose performative containing its three attributes as a 
list: [lightShow, speaker, musicStyle].
\begin{verbatim}
    reflex receiveCFP when: !empty(cfps) {
    loop cfpMsg over: cfps {
        list contents_list <- list(cfpMsg.contents);
        if (contents_list[0] = "stats") {
            do propose message: cfpMsg contents: 
            [lightShow, speaker, musicStyle];
        }
    }
}
\end{verbatim}

All proposals are received in the receiveProposal reflex. 
For each one this reflex calls compute\_utilities 
to score the stage and stores the result in a utilities map.

\begin{verbatim}
    reflex receiveProposals when: hasReceivedUtilities = false and 
    hasRequestedUtilities = true and !empty(proposes){
    loop proposeMsg over: proposes {
        list<int> contents_list <- list<int>(list(proposeMsg.contents));
        do compute_utilities(contents_list, proposeMsg.sender);
    }
    hasReceivedUtilities <- true;
    do select_stage;
}
\end{verbatim}

After processing all proposals, 
the guest invokes select\_stage, which iterates through 
all stages and finds the one with the highest utility score stored in the utilities map.
\begin{verbatim}
    action select_stage {
    int maxUtility <- 0;
    Stage bestStage <- nil;
    loop stage over: stages {
        if (utilities != nil and utilities contains_key(stage)) {
            int stageUtility <- utilities[stage];
            if (stageUtility > maxUtility) {
                maxUtility <- stageUtility;
                bestStage <- stage;
            }
        }
    }
    selectedStage <- bestStage;
}
\end{verbatim}
Once a stage is selected and the current time falls within [startFestivalTime, endFestivalTime], 
the guest computes a random target location near the stage and moves toward it using the moving skill with movingSpeed = 0.75.
Guests navigate to their selected stage, arrive at a random position nearby (within 6–12 units from the stage), 
and then dance continuously



\subsection*{3.3 Demonstration}
I will show below screenshots for two cases; 
\begin{itemize}
    \item Guests request utilities to stages
    \item Guest select the stage with higher utility
\end{itemize}
For the purpose of this demonstration I included only 4 guests 
so that the number of logging messages is reduced.

\subsubsection*{Guests request utilities to stages}
\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{imgs/request_utilities.png}
    \caption{Guest request utilities}
    \label{fig:request_utilities}
\end{figure}

A message is send to the stages in \ref{fig:request_utilities} to request utilities values.

\subsubsection*{Guest select the one with maximum utility}
\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{imgs/calculate_best.png}
    \caption{Guest select the stage with higher utility}
    \label{fig:calculate_best}
\end{figure}

As it can be seen in \ref{fig:calculate_best} each guest is selecting the stage with the highest utility.



% --- SECTION 4 ---
\section{Challenge 1: global utility function}

\subsection*{4.1 Explanation}
Explain the challenge and your approach.

\subsection*{4.2 Code}
Show relevant code snippets and screenshots.

\subsection*{4.3 Demonstration}
Provide 4 complete use cases:

% --- SECTION 5 ---
\section{Final Remarks}
In this homework we learnt a couple of things related to GAMA language and agents coordination.
First of all, we were forced to create a "chain" of messages between agents that were bouncing back messages
one to another (in the first task). Regarding the second task and its challenge it was not so easy 
to find a way to have a leader and to have the agents working together 
towards an objective following a utility function.
We are really happy about our result and we are really looking forward
to the final project which will certainly be more challenging.


\end{document}